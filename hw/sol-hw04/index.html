<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="description" content ="CS88: Computational Structures in Data Science " />
    <meta name="keywords" content ="CS88, Computer Science, Data Science, Programming, David Culler, Berkeley, EECS" />
    <meta name="author" content ="David Culler, Garrett Tan, Gunjan Baid, Richard Liang, Nishant Desai" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width">

    <script src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>

    <link rel="stylesheet" href="/assets/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/style.css">
    <link rel="icon" href="/assets/images/favicon.ico">

    <link rel="stylesheet" href="/assets/css/mono-blue.css">
    <script src="/assets/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <link rel="stylesheet" type="text/css" href="/assets/css/resource.css" />
<link rel="stylesheet" type="text/css" href="../../assets/css/hw.css"/>


    <title>Homework 4 Solutions | CS 88 Spring 2016</title>

  </head>

  <body id="index" class="home">
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-section">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">CS 88</a>
        </div>

        <div class="collapse navbar-collapse" id="navbar-collapse-section">
          <ul class="nav navbar-nav navbar-right">
            <li><a href="/">Calendar</a></li>
            <li><a href="/articles/resources.html">Resources</a></li>
            <li><a href="/office-hours.html">Office Hours</a></li>
            <!--- <li><a href="/tutoring.html">Tutoring</a></li> -->

            <li><a href="/articles/using-ok.html">Using OK</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Course Info <span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="/articles/about.html">Syllabus</a></li>
                <li><a href="/staff.html">Staff</a></li>
                <!-- <li><a href="/weekly.html">Weekly Schedule</a></li> -->
                <!-- <li><a href="/extra.html">Extra Lectures</a></li> -->
              </ul>
            </li>

          </ul>
        </div>
      </div>
    </nav>

    <div id="content" class="container">
      <div class='row'>
  <div class='col-md-9'>
    <div class='page-header'>
      <h1><span class="content-title-brand">Homework 4</span> Solutions</h1>
    </div>

    <p><strong>Solutions:</strong> You can find the file with solutions for all
questions <a href="hw04.py">here</a>.</p>

    
<blockquote><p>Students taking the make-up midterm on Friday 9/25 will automatically receive
full credit for this homework assignment. You should complete it anyway on
your own to learn the material, but when you complete it is up to you.</p></blockquote>


<h2 id="required-questions">Required Questions</h2>


<h3 class="question" id="q1">Question 1</h3>

<p>A list that contains one or more lists as elements is called a <em>deep</em>
list. For example, <code>[1, [2, 3], 4]</code> is a deep list.</p>

<p>Write a function <code>deep_len</code> that takes a list and returns its deep
length. See the doctests for the function's behavior.</p>

<p><em>Hint</em>: you can check if something is a list by using the built-in
<code>type</code> function. For example,</p>

<pre><code>&gt;&gt;&gt; type(3) == list
False
&gt;&gt;&gt; type([1, 2, 3]) == list
True</code></pre>

<solution>

<pre><code>def deep_len(lst):
    &quot;&quot;&quot;Returns the deep length of the list.

    &gt;&gt;&gt; deep_len([1, 2, 3])     # normal list
    3
    &gt;&gt;&gt; x = [1, [2, 3], 4]      # deep list
    &gt;&gt;&gt; deep_len(x)
    4
    &gt;&gt;&gt; x = [[1, [1, 1]], 1, [1, 1]] # deep list
    &gt;&gt;&gt; deep_len(x)
    6
    &quot;&quot;&quot;
<span class="sol-highlight">    if not lst:
        return 0
    elif type(lst[0]) == list:
        return deep_len(lst[0]) + deep_len(lst[1:])
    else:
        return 1 + deep_len(lst[1:])</span></code></pre>

</solution>

<p>Use OK to test your code:</p><pre><code>python3 ok -q deep_len</code></pre>


<h3 id="intervals-data-abstraction">Intervals (data abstraction)</h3>


<p><strong>Acknowledgements.</strong> This interval arithmetic example is based on
a classic problem from Structure and Interpretation of Computer Programs,
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-14.html#%_sec_2.1.4">Section 2.1.4</a>.</p>

<p><strong>Introduction.</strong> Alyssa P. Hacker is designing a system to help people
solve engineering problems. One feature she wants to provide in her
system is the ability to manipulate inexact quantities (such as
measured parameters of physical devices) with known precision, so that
when computations are done with such approximate quantities the results
will be numbers of known precision.</p>

<p>Alyssa's idea is to implement interval arithmetic as a set of
arithmetic operations for combining "intervals" (objects that represent
the range of possible values of an inexact quantity). The result of
adding, subracting, multiplying, or dividing two intervals is itself an
interval, representing the range of the result.</p>

<p>Alyssa postulates the existence of an abstract object called an
"interval" that has two endpoints: a lower bound and an upper bound.
She also presumes that, given the endpoints of an interval, she can
construct the interval using the data constructor interval.   Using the
constructor and selectors, she defines the following operations:</p>

<pre><code>def str_interval(x):
    &quot;&quot;&quot;Return a string representation of interval x.

    &gt;&gt;&gt; str_interval(interval(&#x2d;1, 2))
    &#x27;&#x2d;1 to 2&#x27;
    &quot;&quot;&quot;
    return &#x27;{0} to {1}&#x27;.format(lower_bound(x), upper_bound(x))

def add_interval(x, y):
    &quot;&quot;&quot;Return an interval that contains the sum of any value in interval x and
    any value in interval y.

    &gt;&gt;&gt; str_interval(add_interval(interval(&#x2d;1, 2), interval(4, 8)))
    &#x27;3 to 10&#x27;
    &quot;&quot;&quot;
    lower = lower_bound(x) + lower_bound(y)
    upper = upper_bound(x) + upper_bound(y)
    return interval(lower, upper)

def mul_interval(x, y):
    &quot;&quot;&quot;Return the interval that contains the product of any value in x and any
    value in y.

    &gt;&gt;&gt; str_interval(mul_interval(interval(&#x2d;1, 2), interval(4, 8)))
    &#x27;&#x2d;8 to 16&#x27;
    &quot;&quot;&quot;
    p1 = lower_bound(x) * lower_bound(y)
    p2 = lower_bound(x) * upper_bound(y)
    p3 = upper_bound(x) * lower_bound(y)
    p4 = upper_bound(x) * upper_bound(y)
    return interval(min(p1, p2, p3, p4), max(p1, p2, p3, p4))</code></pre>

<h3 class="question" id="q2">Question 2</h3>

<p>Alyssa's program is incomplete because she has not specified the
implementation of the interval abstraction. Define the constructor and
selectors in terms of two-element lists:</p>

<pre><code>def interval(a, b):
    &quot;&quot;&quot;Construct an interval from a to b.&quot;&quot;&quot;
<span class="sol-highlight">    return [a, b]</span>

def lower_bound(x):
    &quot;&quot;&quot;Return the lower bound of interval x.&quot;&quot;&quot;
<span class="sol-highlight">    return x[0]</span>

def upper_bound(x):
    &quot;&quot;&quot;Return the upper bound of interval x.&quot;&quot;&quot;
<span class="sol-highlight">    return x[1]</span></code></pre>

<p>Use OK to test your code:</p><pre><code>python3 ok -q str_interval
python3 ok -q add_interval
python3 ok -q mul_interval</code></pre>

<h3 class="question" id="q3">Question 3</h3>

<p>Alyssa implements division below, by multiplying by the reciprocal of
<code>y</code>. Ben Bitdiddle, an expert systems programmer, looks over Alyssa's
shoulder and comments that it is not clear what it means to divide by
an interval that spans zero. Add an assert statement to Alyssa's code
to ensure that no such interval is used as a divisor:</p>

<pre><code>def div_interval(x, y):
    &quot;&quot;&quot;Return the interval that contains the quotient of any value in x divided by any value in y.

    Division is implemented as the multiplication of x by the reciprocal of y.

    &gt;&gt;&gt; str_interval(div_interval(interval(&#x2d;1, 2), interval(4, 8)))
    &#x27;&#x2d;0.25 to 0.5&#x27;
    &gt;&gt;&gt; str_interval(div_interval(interval(4, 8), interval(&#x2d;1, 2)))
    AssertionError
    &quot;&quot;&quot;
<span class="sol-highlight">    assert lower_bound(y) &gt; 0 or upper_bound(y) &lt; 0, &#x27;Divide by zero&#x27;</span>
    reciprocal_y = interval(1/upper_bound(y), 1/lower_bound(y))
    return mul_interval(x, reciprocal_y)</code></pre>

<p>Use OK to test your code:</p><pre><code>python3 ok -q div_interval</code></pre>

<h3 class="question" id="q4">Question 4</h3>

<p>Using reasoning analogous to Alyssa's, define a subtraction function
for intervals:</p>

<pre><code>def sub_interval(x, y):
    &quot;&quot;&quot;Return the interval that contains the difference between any value in x
    and any value in y.

    &gt;&gt;&gt; str_interval(sub_interval(interval(&#x2d;1, 2), interval(4, 8)))
    &#x27;&#x2d;9 to &#x2d;2&#x27;
    &quot;&quot;&quot;
<span class="sol-highlight">    negative_y = interval(&#x2d;upper_bound(y), &#x2d;lower_bound(y))
    return add_interval(x, negative_y)</span></code></pre>

<h3 class="question" id="q5">Question 5</h3>

<p>After considerable work, Alyssa P. Hacker delivers her finished system.
Several years later, after she has forgotten all about it, she gets a
frenzied call from an irate user, Lem E. Tweakit. It seems that Lem has
noticed that the formula for parallel resistors can be written in two
algebraically equivalent ways:</p>

<pre><code>par1(r1, r2) = (r1 * r2) / (r1 + r2)</code></pre>

<p>or</p>

<pre><code>par2(r1, r2) = 1 / (1/r1 + 1/r2)</code></pre>

<p>He has written the following two programs, each of which computes the
<code>parallel_resistors</code> formula differently::</p>

<pre><code>def par1(r1, r2):
    return div_interval(mul_interval(r1, r2), add_interval(r1, r2))

def par2(r1, r2):
    one = interval(1, 1)
    rep_r1 = div_interval(one, r1)
    rep_r2 = div_interval(one, r2)
    return div_interval(one, add_interval(rep_r1, rep_r2))</code></pre>

<p>Lem complains that Alyssa's program gives different answers for the two
ways of computing. This is a serious complaint.</p>

<p>Demonstrate that Lem is right. Investigate the behavior of the system
on a variety of arithmetic expressions. Make some intervals <code>a</code> and
<code>b</code>, and show that <code>par1</code> and <code>par2</code> can give different results.</p>

<pre><code># These two intervals give different results for parallel resistors:
<span class="sol-highlight">a = make_center_percent(1, 1)
b = make_center_percent(2, 1)
print(str_interval(par1(a, b)), &#x27;!=&#x27;, str_interval(par2(a, b)))</span></code></pre>

<p><em>Note</em>: No tests will be run on your solution to this problem. Any answer will
be accepted, but please attempt to answer the question correctly.</p>

<h3 class="question" id="q6">Question 6</h3>

<p>Eva Lu Ator, another user, has also noticed the different intervals
computed by different but algebraically equivalent expressions. She
says that the problem is multiple references to the same interval.</p>

<p>The Multiple References Problem: a formula to compute with intervals
using Alyssa's system will produce tighter error bounds if it can be
written in such a form that no variable that represents an uncertain
number is repeated.</p>

<p>Thus, she says, <code>par2</code> is a better program for parallel resistances
than <code>par1</code>. Is she right? Why? Write a function that returns a string
containing a written explanation of your answer:</p>

<pre><code>def multiple_references_explanation():
<span class="sol-highlight">    return &quot;&quot;&quot;The multiple reference problem exists.  The true value
    within a particular interval is fixed (though unknown).  Nested
    combinations that refer to the same interval twice may assume two different
    true values for the same interval, which is an error that results in
    intervals that are larger than they should be.

    Consider the case of i * i, where i is an interval from &#x2d;1 to 1.  No value
    within this interval, when squared, will give a negative result.  However,
    our mul_interval function will allow us to choose 1 from the first
    reference to i and &#x2d;1 from the second, giving an erroneous lower bound of
    &#x2d;1.

    Hence, a program like par2 is better than par1 because it never combines
    the same interval more than once.
    &quot;&quot;&quot;</span></code></pre>

<p><em>Note</em>: No tests will be run on your solution to this problem. Any answer will
be accepted, but please attempt to answer the question correctly.</p>

<h3 class="question" id="q7">Question 7</h3>

<p>Write a function <code>quadratic</code> that returns the interval of all values
<code>f(t)</code> such that <code>t</code> is in the argument interval <code>x</code> and <code>f(t)</code> is a
<a href="http://en.wikipedia.org/wiki/Quadratic_function">quadratic function</a>:</p>

<pre><code>f(t) = a*t*t + b*t + c</code></pre>

<p>Make sure that your implementation returns the smallest such interval,
one that does not suffer from the multiple references problem.</p>

<p><em>Hint</em>: the derivative <code>f&#x27;(t) = 2*a*t + b</code>, and so the extreme
point of the quadratic is <code>&#x2d;b/(2*a)</code>:</p>

<pre><code>def quadratic(x, a, b, c):
    &quot;&quot;&quot;Return the interval that is the range of the quadratic defined by
    coefficients a, b, and c, for domain interval x.

    &gt;&gt;&gt; str_interval(quadratic(interval(0, 2), &#x2d;2, 3, &#x2d;1))
    &#x27;&#x2d;3 to 0.125&#x27;
    &gt;&gt;&gt; str_interval(quadratic(interval(1, 3), 2, &#x2d;3, 1))
    &#x27;0 to 10&#x27;
    &quot;&quot;&quot;
<span class="sol-highlight">    extremum = &#x2d;b / (2*a)
    f = lambda x: a * x * x + b * x + c
    l, u, e = map(f, (lower_bound(x), upper_bound(x), extremum))
    if extremum &gt;= lower_bound(x) and extremum &lt;= upper_bound(x):
        return interval(min(l, u, e), max(l, u, e))
    else:
        return interval(min(l, u), max(l, u))</span></code></pre>

<p>Use OK to test your code:</p><pre><code>python3 ok -q quadratic</code></pre>


<h2 id="extra-questions">Extra Questions</h2>


<blockquote><p>Extra questions are not worth extra credit and are entirely optional. They are
designed to challenge you to think creatively!</p></blockquote>

<h3 class="question" id="q8">Question 8</h3>

<p>Write a function polynomial that takes an interval <code>x</code> and a list of
coefficients <code>c</code>, and returns the interval containing all values of
<code>f(t)</code> for <code>t</code> in interval <code>x</code>, where:</p>

<pre><code>f(t) = c[k&#x2d;1] * pow(t, k&#x2d;1) + c[k&#x2d;2] * pow(t, k&#x2d;2) + ... + c[0] * 1</code></pre>

<p>Like quadratic, your polynomial function should return the smallest
such interval, one that does not suffer from the multiple references
problem.</p>

<p><em>Hint</em>: You can approximate this result. Try using <a href="http://www.composingprograms.com/pages/16-higher-order-functions.html#example-newton-s-method">Newton's
method</a>.</p>

<pre><code>def polynomial(x, c):
    &quot;&quot;&quot;Return the interval that is the range of the polynomial defined by
    coefficients c, for domain interval x.

    &gt;&gt;&gt; str_interval(polynomial(interval(0, 2), [&#x2d;1, 3, &#x2d;2]))
    &#x27;&#x2d;3 to 0.125&#x27;
    &gt;&gt;&gt; str_interval(polynomial(interval(1, 3), [1, &#x2d;3, 2]))
    &#x27;0 to 10&#x27;
    &gt;&gt;&gt; str_interval(polynomial(interval(0.5, 2.25), [10, 24, &#x2d;6, &#x2d;8, 3]))
    &#x27;18.0 to 23.0&#x27;
    &quot;&quot;&quot;
<span class="sol-highlight">    def add_fn(coeff, k, f):
        return lambda x: coeff * pow(x, k) + f(x)

    def add_dfn(coeff, k, df):
        return lambda x: k * coeff * pow(x, k&#x2d;1) + df(x)

    def add_ddfn(coeff, k, ddf):
        return lambda x: k * (k&#x2d;1) * coeff * pow(x, k&#x2d;2) + ddf(x)

    # Define the polynomial and its first and second derivatives.
    f = lambda x: 0
    df = lambda x: 0
    ddf = lambda x: 0
    for k, coeff in enumerate(c):
        f = add_fn(coeff, k, f)
        if k &gt; 0:
            df = add_dfn(coeff, k, df)
        if k &gt; 1:
            ddf = add_ddfn(coeff, k, ddf)

    # Find as many extreme points as we can using Newton&#x27;s method
    lower, upper = lower_bound(x), upper_bound(x)
    num_steps = 20
    step = (upper &#x2d; lower) / num_steps
    starts = [lower + k * step for k in range(num_steps)]
    extremums = [find_zero(df, ddf, n) for n in starts]

    # Filter for the interval x and return
    ns = [n for n in extremums if n &gt; lower and n &lt; upper] + [lower, upper]
    values = [f(n) for n in ns]
    return interval(min(values), max(values))</span>

<span class="sol-highlight"># Newton&#x27;s method from lecture

def improve(update, close, guess=1, max_updates=100):
    &quot;&quot;&quot;Iteratively improve guess with update until close(guess) is true or
    max_updates have been applied.&quot;&quot;&quot;
    k = 0
    while not close(guess) and k &lt; max_updates:
        guess = update(guess)
        k = k + 1
    return guess

def approx_eq(x, y, tolerance=1e&#x2d;15):
    return abs(x &#x2d; y) &lt; tolerance

def find_zero(f, df, guess=1):
    &quot;&quot;&quot;Return a zero of the function f with derivative df.&quot;&quot;&quot;
    def near_zero(x):
        return approx_eq(f(x), 0)
    return improve(newton_update(f, df), near_zero, guess)

def newton_update(f, df):
    &quot;&quot;&quot;Return an update function for f with derivative df,
    using Newton&#x27;s method.&quot;&quot;&quot;
    def update(x):
        return x &#x2d; f(x) / df(x)
    return update</span></code></pre>

  </div>

  <div class='col-md-3'>
    <nav class='hidden-print hidden-sm hidden-xs sidebar'>
      <ul>
  <li><a href="#required-questions">Required Questions</a></li>
  <ul>
  <li><a href="#q1">Question 1</a></li>
  <li><a href="#intervals-data-abstraction">Intervals (data abstraction)</a></li>
  <li><a href="#q2">Question 2</a></li>
  <li><a href="#q3">Question 3</a></li>
  <li><a href="#q4">Question 4</a></li>
  <li><a href="#q5">Question 5</a></li>
  <li><a href="#q6">Question 6</a></li>
  <li><a href="#q7">Question 7</a></li>
</ul>

  <li><a href="#extra-questions">Extra Questions</a></li>
  <ul>
  <li><a href="#q8">Question 8</a></li>
</ul>

</ul>

    </nav>
  </div>

</div>
    </div>
  </body>
  <script>
  $('.sidebar ul').addClass('nav nav-stacked');
  $('body').scrollspy({
    target: '.sidebar',
    offset: 40
  });
</script>

</html>
